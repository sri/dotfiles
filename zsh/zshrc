# -*- mode: sh -*-

typeset -U path PATH

path=(~/my/dotfiles/bin "$path[@]")

# asdf
# https://asdf-vm.com/guide/getting-started.html
if [[ -e "$HOME/.asdf/asdf.sh" ]]; then
  echo loading asdf.sh
  . "$HOME/.asdf/asdf.sh"
  # append completions to fpath
  fpath=(${ASDF_DIR}/completions $fpath)
fi

# initialise completions with ZSH's compinit
autoload -Uz compinit && compinit
eval "$(~/.rbenv/bin/rbenv init - zsh)"

# https://unix.stackexchange.com/questions/273861/unlimited-history-in-zsh
HISTFILE="$HOME/.zsh_history"
HISTSIZE=10000
SAVEHIST=10000
setopt BANG_HIST                 # Treat the '!' character specially during expansion.
setopt EXTENDED_HISTORY          # Write the history file in the ":start:elapsed;command" format.
setopt INC_APPEND_HISTORY        # Write to the history file immediately, not when the shell exits.
setopt SHARE_HISTORY             # Share history between all sessions.
setopt HIST_EXPIRE_DUPS_FIRST    # Expire duplicate entries first when trimming history.
setopt HIST_IGNORE_DUPS          # Don't record an entry that was just recorded again.
setopt HIST_IGNORE_ALL_DUPS      # Delete old recorded entry if new entry is a duplicate.
setopt HIST_FIND_NO_DUPS         # Do not display a line previously found.
setopt HIST_IGNORE_SPACE         # Don't record an entry starting with a space.
setopt HIST_SAVE_NO_DUPS         # Don't write duplicate entries in the history file.
setopt HIST_REDUCE_BLANKS        # Remove superfluous blanks before recording entry.
setopt HIST_VERIFY               # Don't execute immediately upon history expansion.
setopt HIST_BEEP                 # Beep when accessing nonexistent history.

export PYTHONSTARTUP=~/.pythonrc.py
export RIPGREP_CONFIG_PATH=~/.ripgreprc


# Load Git prompt functions
autoload -Uz vcs_info
zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' formats '(%b)'

function preexec() {
  # Record the start time of the command
  cmd_start_time=$SECONDS
}

preexec_functions+=(preexec)


# Function to customize the prompt
function custom_prompt() {
  # Get the exit status of the last command
  # NOTE: this needs to be the first statement in this function.
  local last_exit_status=$?

  local cmd_duration=$((SECONDS - cmd_start_time))

  # Get the current Git branch, if any
  vcs_info

  # Display a green checkmark for successful commands, red 'x' for failed ones
  local prompt_status
  if [ $last_exit_status -eq 0 ]; then
    prompt_status="%F{green}✔%f"
  else
    prompt_status="%F{red}✘%f"
  fi

  # Set the prompt (PS1)
  PROMPT="%F{cyan}%D{%H:%M:%S}%f %F{magenta}[%~]%f ${vcs_info_msg_0_} {$cmd_duration s:$prompt_status}"$'\n'"→ "

}

# Set the precmd function to be called before each command execution
precmd_functions+=(custom_prompt)

if [[ -e $HOME/.cargo/env ]]; then
  . $HOME/.cargo/env
fi


# Aliases
alias sub="/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl"

alias tab='open . -a iterm'

alias d='git diff'
#__git_complete d _git_diff
alias gd='git diff'
#__git_complete gd _git_diff
alias s='git status --short --branch'
alias gs='git status'
alias gg='git grep'
alias ggi='git grep -i'


function gc() {
  if [ $# -eq 0 ]; then
    url="$(pbpaste)"
    if [[ "$url" == http* ]]; then
      git clone "$url"
    else
      echo "Error: Clipboard content does not start with 'http'."
    fi
  else
    git clone "$1"
  fi
}


function g() {
    local search=$1
    local downcased=${search,,}

    if [ "$search" = "$downcased" ]; then
        # If all lowercase, do a case-insensitive search.
        git grep --color --break -n -i "$1"
    else
        # Otherwise search for that term exactly.
        git grep --color --break -n "$1"
    fi
}


alias gcontains='git branch -a --contains'
alias gwhich='git branch -a | grep -i '
alias gss='git show -p'
alias gds='git diff --staged'

alias gl='git log --graph --all --decorate --oneline -5'
#__git_complete gl _git_log

alias gall='git log --graph --all --decorate --no-merges'

alias glp='gl -p'
#__git_complete glp _git_log
alias gp='git pull'

alias cdr='cd "$(git rev-parse --show-toplevel)"'

alias ip="dig +short myip.opendns.com @resolver1.opendns.com"

alias ..='c ..'
alias dt='c ~/Desktop'
alias cddotfiles='c ~/my/dotfiles'

alias x='chmod +x'

alias rr='. ~/.zshrc'
alias brc='emacsclient ~/.zshrc; . ~/.zshrc'

alias df='df -h'
alias du='du -c -h'
alias du1='du --max-depth=1'

alias topcmds='cat ~/.zsh_history | awk -F";" "{ print $2 }" | cut -d " " -f1 | sort | uniq -c | sort -nr | head -15'

alias ll='eza --long --sort modified --total-size --almost-all --group-directories-first'
alias llsz='eza --long --sort size --total-size --almost-all --group-directories-first'
alias llt='eza --tree'

# alias ll='ls -ltr --color=auto'
# alias lsz='ls -lSrh --color=auto'

# From https://blog.cloudflare.com/a-question-of-timing/
alias curl_info='curl -so /dev/null -w "dnslookup: %{time_namelookup} | connect: %{time_connect} | appconnect: %{time_appconnect} | pretransfer: %{time_pretransfer} | starttransfer: %{time_starttransfer} | total: %{time_total} | size: %{size_download}\n"'


alias r='my_ruby'
function my_ruby() {
    if [ -f ./Gemfile ]; then
        if [ -n "$INSIDE_EMACS" ]; then
            rails console -- --inf-ruby-mode
        else
            rails console
        fi
    else
        if [ -n "$INSIDE_EMACS" ]; then
            irb --inf-ruby-mode
        else
            irb
        fi
    fi
}

alias p='my_python'
function my_python() {
    if [ -x "$(command -v ipython)" ]; then
        if [ -n "$INSIDE_EMACS" ]; then
            ipython --simple-prompt "$@"
        else
            ipython "$@"
        fi
    elif [ -x "$(command -v python3)" ]; then
        python3 "$@"
    else
        python "$@"
    fi
}


# Run `less' if argument is a file, otherwise `ls'.
alias l='my_ls'
function my_ls() {
  if [ $# = 1 ]; then
    if [ -f $1 ]; then
      less $1;
      return
    fi
  fi
  ll $*;
}

alias c="cd_ls"
function cd_ls () {
   if [ $# = 0 ]; then
      cd && ls -G
   else
      cd "$*" && ls -G
   fi
}

function e() {
    ~/progs/emacs/bin/emacs &
#    if [ "$TMUX" = "" ]; then
#        ~/src/emacs/src/emacs -nw "$@"
#    else
#        TERM=xterm-256color emacs -nw "$@"
#    fi#
}

# Prints value of env var passed in.
# This is so you don't have to type the variable upcased.
function ev() {
    local arg="$1"
    local envvar="${arg^^}"
    eval echo $envvar=\${$envvar}
}

# Same as `ev' but prints all matches
function evall() {
    local arg="$1"
    local envvar="${arg^^}"
    eval env | grep $envvar | sort
}

function find_broken_symlinks() {
    find . -type l ! -exec test -e {} \; -print
}

if [[ -e ~/.zshrc_private ]]; then
  . ~/.zshrc_private
fi
