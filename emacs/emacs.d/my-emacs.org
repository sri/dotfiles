* Intro

Trying the all emacs config in one org mode file. Before I had a file
for each category (eg, my-isearch.el) and had those byte-compiled
before loading them into Emacs.

* My packages

The packages that I currently like.

#+BEGIN_SRC emacs-lisp
  (defvar my-packages
    '(
      autopair
      bm
      browse-kill-ring
      coffee-mode
      elisp-slime-nav
      flycheck
      go-mode
      swiper
      macrostep
      magit
      org
      projectile
      rainbow-mode
      ruby-end
      smart-mode-line
      solarized-theme
      visual-regexp
      yasnippet
      ))
#+END_SRC

Add MELPA and install any missing packages.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.milkbox.net/packages/") t)

  (package-initialize)

  (let ((missing '()))
    (dolist (p my-packages)
      (unless (package-installed-p p)
        (push p missing)))
    (when missing
      (package-refresh-contents)
      (dolist (p missing)
        (package-install p))))

#+END_SRC

** Load up solarized

It doesn't work well on terminals.

#+BEGIN_SRC emacs-lisp
(when window-system
  (load-theme 'solarized-dark t)
  (custom-theme-set-faces
   'solarized-dark
   '(dired-header ((t (:foreground "#268bd2" :underline t :background nil))))))
#+END_SRC

** Autopair

Like it turned on globally.

#+BEGIN_SRC emacs-lisp
(require 'autopair)
(autopair-global-mode)
#+END_SRC

** bm: buffer bookmarks

#+BEGIN_SRC emacs-lisp
(require 'bm)
(setq bm-highlight-style
      (if window-system
          'bm-highlight-only-fringe
        'bm-highlight-only-line))

#+END_SRC

** coffee-mode
#+BEGIN_SRC emacs-lisp
(require 'coffee-mode)
(setq coffee-tab-width 2)
#+END_SRC

** elisp-slime-nav
#+BEGIN_SRC emacs-lisp
(require 'elisp-slime-nav)
(add-hook 'emacs-lisp-mode-hook 'turn-on-elisp-slime-nav-mode)
#+END_SRC

** smart-mode-line

#+BEGIN_SRC emacs-lisp
(require 'advice)
(require 'smart-mode-line)

(sml/setup)
(sml/apply-theme 'dark)

(defun my-mode-line-copy-full-path ()
  "Copies the buffer name to the kill ring.
If that is nil, then it is mode specific as to what gets copied:
 - shell or magit modes, copies the default directory."
  (interactive)
  (let ((name (or (buffer-file-name)
                  (cond ((eq major-mode 'shell-mode)
                         default-directory)
                        ((string-prefix-p "Magit" mode-name)
                         default-directory)))))
    (when name
      (kill-new name)
      (message "Copied `%s'" name))))

(defadvice sml/generate-buffer-identification (after my-mode-line-mouse-click (&rest ignored))
  (add-text-properties 0 (length sml/buffer-identification)
                       '(help-echo "Click to copy buffer name to kill ring")
                       sml/buffer-identification)
  ad-return-value)
(ad-activate 'sml/generate-buffer-identification)

(define-key mode-line-buffer-identification-keymap
  [mode-line mouse-1] 'my-mode-line-copy-full-path)
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
(require 'advice)

(require 'yasnippet)

(setq yas-snippet-dirs '("~/.emacs.d/snippets"))
(yas-global-mode 1)

;; I have yas working with hippie-expand.
(define-key yas-minor-mode-map [(tab)] nil)
(define-key yas-minor-mode-map (kbd "TAB") nil)

(defadvice yas--modes-to-activate (after my-yas-activate-global-mode ())
  (let ((modes ad-return-value))
    (setq ad-return-value (append modes (list 'global-mode)))))

(ad-activate 'yas--modes-to-activate)
#+END_SRC

** swiper
#+BEGIN_SRC emacs-lisp
(ivy-mode 1)
(setq ivy-use-virtual-buffers t)
(global-set-key (kbd "C-c C-r") 'ivy-resume)
#+END_SRC

* Non-packages (not installable thru the package manager)
** eval-expr

Pretty prints eval-expression (ESC-:, Alt-:) in a buffer if too big
for the minibuffer.

#+BEGIN_SRC emacs-lisp
(load (expand-file-name "~/.emacs.d/third-party/eval-expr.el"))
#+END_SRC

* My enhancements
** Magit
#+BEGIN_SRC emacs-lisp
(require 'magit)
(require 'advice)

(defadvice magit-show-level-1-all (after my-magit-show-level-1-all)
  (goto-char (point-max))
  (next-line -1)
  (magit-toggle-section))
(ad-activate 'magit-show-level-1-all)

(setq magit-last-seen-setup-instructions "1.4.0")
(setq magit-diff-highlight-hunk-body nil)
(defun my-git-grep ()
  (interactive)
  (let* ((search (if (use-region-p)
                     (buffer-substring-no-properties (region-beginning)
                                                     (region-end))
                   (completing-read "git grep: "
                                    nil nil nil (current-word))))
         (cmd (concat "cd \"%s\" && "
                      "git --no-pager grep -P -n \"%s\" "
                      "`git rev-parse --show-toplevel`"))
         (buffer-name (format "*git grep: %s*" search))
         (compilation-buffer-name-function
          ;; Fix me: should return unique name
          (lambda (ignore) buffer-name)))
    (with-current-buffer (get-buffer-create buffer-name)
      (setq truncate-lines t))
    (grep-find (format cmd (expand-file-name default-directory)
                       search))))

(defun my-magit-view-diff ()
  "View each file diff.
Find the first diff section (after point) and opens it up for
viewing.  Subsequent calls to this command will either scroll
thru the diff until the end is visible on the window. After that,
it'll close the current section and open the next one."
  (interactive)
  (let ((continue (eq last-command 'my-magit-view-diff))
        (current (magit-current-section))
        (done nil))
    ;; Find a diff or hunk section after point
    (while (and (not done)
                (not (member (magit-section-type current) '(diff hunk))))
      (if (null (magit-find-section-after (point)))
          (setq done t)
        (magit-goto-next-section)
        (setq current (magit-current-section))
        ;; magit-diff ends with a "back" button and it seems to be
        ;; considered a magit section.
        (when (eq (magit-section-type current) 'button)
          (setq done t))))
    (cond (done
           (message "Done"))
          ((or continue
               (eq (magit-section-type current) 'hunk))
           (let ((parent (if (eq (magit-section-type current) 'diff)
                             current
                           (magit-section-parent current))))
             (unless (eq (magit-section-type parent) 'diff)
               (error "Parent of hunk is not a diff but is %s"
                      (magit-section-type parent)))
             ;; If the current diff has more content that is visible
             ;; in the current window, scroll up and let the user view
             ;; it.  Otherwise, close this diff section and open the
             ;; next one.
             (cond ((pos-visible-in-window-p (magit-section-end parent))
                    (goto-char (magit-section-beginning parent))
                    (magit-hide-section)
                    (recenter 0)
                    (if (null (magit-find-section-after (point)))
                        (message "Done")
                      (magit-goto-next-section)
                      (if (eq (magit-section-type (magit-current-section)) 'diff)
                          (magit-show-section)
                        (message "Done"))))
                   (t (scroll-up)))))
          ((eq (magit-section-type current) 'diff)
           ;; Initial viewing
           (goto-char (magit-section-beginning current))
           (magit-show-section)
           (recenter 0)))))

(mapc (lambda (mode-map)
        (define-key mode-map (kbd ",")
          'my-magit-view-diff))
      (list magit-status-mode-map
            magit-diff-mode-map))

;; Don't highlight sections.
(defun magit-highlight-section ()
  nil)

(add-hook 'magit-log-edit-mode-hook 'turn-on-auto-fill)

(setq magit-status-buffer-switch-function 'switch-to-buffer)

;; (defun my-magit-close-current-open-next ()
;;   (interactive)
;;   (magit-goto-parent-section)
;;   (magit-toggle-section)
;;   (magit-goto-next-section)
;;   (recenter 0))

;; (defun my-magit-click ()
;;   (cond ((memq major-mode '(magit-log-mode magit-branch-manager-mode))
;;          (magit-show-item-or-scroll-up))
;;         ((eq major-mode 'magit-status-mode)
;;          (let* ((current (magit-current-section))
;;                 (current-title (format "%s" (magit-section-title current)))
;;                 (parent (magit-section-parent current)))
;;            (if (and parent
;;                     (eq (magit-section-title parent) 'stashes))
;;                (magit-show-item-or-scroll-up)
;;              (unless (string-prefix-p "@@" current-title)
;;                (magit-toggle-section)))))
;;         ((memq major-mode '(magit-wazzup-mode
;;                             magit-commit-mode
;;                             magit-log-edit-mode
;;                             magit-stash-mode
;;                             magit-reflog-mode
;;                             magit-diff-mode))
;;          (magit-toggle-section))))

#+END_SRC

** Org mode
#+BEGIN_SRC emacs-lisp
(require 'org)

(set-register ?t '(file . "~/Dropbox/Notes/todo.org"))

(setq org-agenda-files '("~/Dropbox/Notes"))

(add-hook 'org-mode-hook
          (lambda ()
            ;; 3rd arg T says to modify the buffer-local hook
            (remove-hook 'before-save-hook 'delete-trailing-whitespace t)
            (setq cursor-type 'bar)))

(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   ;; (awk . t)
   ;; (calc . t)
   ;; (clojure . t)
   (emacs-lisp . t)
   ;; (gnuplot . t)
   ;; (haskell . t)
   ;; (ocaml . t)
   ;; (org . t)
   (python . t)
   (ruby . t)
   ;; (sh . t)
   ;; (sql . t)
   ;; (sqlite . t)
   ))

(setq org-hide-leading-stars t)
(setq org-special-ctrl-a/e t)
(setq org-special-ctrl-k nil)
(setq org-return-follows-link t)
(setq org-use-speed-commands t)
(setq org-hide-leading-stars nil)
(setq org-fontify-done-headline t)
(setq org-closed-keep-when-no-todo t)
(setq org-log-done 'time)

(custom-set-faces
  '(org-done ((t (:strike-through t))))
  '(org-headline-done ((t (:strike-through t)))))

(defun my-org-insert-chrome-link ()
  (interactive)
  (let ((subject (do-applescript "tell application \"Google Chrome\"
                                  title of active tab of front window
                                  end tell"))
        (url (do-applescript "tell application \"Google Chrome\"
                              URL of active tab of front window
                              end tell")))
    (insert (org-make-link-string url subject))))

#+END_SRC

** Sublime-like helpers
#+BEGIN_SRC emacs-lisp
(defun my-swap-line-or-region-down ()
  "Move the current line or region down one line."
  (interactive "*")
  (let (beg end line reg-beg reg-end)
    (when (use-region-p)
      (setq reg-beg (region-beginning))
      (setq reg-end (region-end)))
    ;; Save & delete the next line.
    (save-excursion
      (forward-line 1)
      (setq beg (point))
      (forward-line 1)
      (setq end (point)))
    (setq line (buffer-substring beg end))
    (delete-region beg end)
    (when reg-beg (goto-char reg-beg))
    (beginning-of-line)
    (insert line)
    (when reg-beg
      (set-mark (+ reg-beg (length line)))
      (goto-char (+ reg-end (length line)))
      (setq deactivate-mark nil))))

(defun my-swap-line-or-region-up ()
  "Move the current line or region up one line."
  (interactive "*")
  (let (beg end line reg-beg reg-end)
    (when (use-region-p)
      (setq reg-beg (region-beginning))
      (setq reg-end (region-end)))
    ;; Save & delete the previous line.
    (save-excursion
      (when reg-beg (goto-char reg-beg))
      (forward-line -1)
      (setq beg (point))
      (forward-line 1)
      (setq end (point)))
    (setq line (buffer-substring beg end))
    (delete-region beg end)
    (save-excursion
      (when reg-end (goto-char (- reg-end (length line))))
      (forward-line 1)
      (insert line))
    (when reg-end
      (set-mark (- reg-beg (length line)))
      (goto-char (- reg-end (length line)))
      (setq deactivate-mark nil))))

(defvar my-line-or-region-swap-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map [down] 'my-swap-line-or-region-down)
    (define-key map [up] 'my-swap-line-or-region-up)
    map))

(defun my-start-line-or-region-swap ()
  (interactive)
  (message "Hit [up] or [down] to move region or line in that direction")
  (set-temporary-overlay-map my-line-or-region-swap-keymap t))

(defun my-duplicate-line-or-region ()
  "Duplicate line or current region."
  (interactive "*")
  (if (use-region-p)
      (let* ((start (region-beginning))
             (end (region-end))
             (region (buffer-substring start end)))
        (cond ((= (point) start)
               (goto-char end)
               (insert region)
               (goto-char start))
              (t (insert region)))
        (set-mark end)
        (setq deactivate-mark nil))
    (let ((line (buffer-substring (point-at-bol) (point-at-eol)))
          (column (current-column)))
      (end-of-line)
      (if (eobp)
          (insert "\n")
        (forward-char 1))
      (save-excursion
        (insert line)
        (unless (eobp) (insert "\n")))
      (move-to-column column))))

(defun my-comment-line-or-region ()
  "Comment or uncomment the current line or region."
  (interactive "*")
  (cond ((use-region-p)
         (let ((start (region-beginning))
               (end (region-end)))
           (save-excursion
             (goto-char start)
             (setq start (point-at-bol))
             (goto-char end)
             (setq end
                   ;; Sublime-like behavior: If the region extends to
                   ;; the beginning of a line, don't include that
                   ;; line.
                   (cond ((bolp)
                          (forward-char -1)
                          (point))
                         (t (point-at-eol)))))
           (comment-or-uncomment-region start end)
           (setq deactivate-mark nil)))
        (t
         (comment-or-uncomment-region (point-at-bol)
                                      (point-at-eol)))))

(defun my-sublime-expand-selection-to-indentation ()
  (interactive)
  "Expand selection to the next indentation level.
Inspired by Sublime Text."
  (let ((n (current-indentation))
        (beg (point-at-bol))
        (end (point-at-eol)))
    ;; when region is active & transient mark mode is
    ;; turned on, we expand to make that region bigger
    (when (and (use-region-p) transient-mark-mode)
      (setq beg (region-beginning)
            end (region-end))
      (save-excursion
        ;; get the min indentation within the region
        (goto-char beg)
        (forward-line 1)
        (while (< (point) end)
          (setq n (min n (current-indentation)))
          (forward-line 1))
        ;; get the min indentation of line before
        ;; region start, line after region start or n
        (setq n
              (max (progn
                     (goto-char beg)
                     (forward-line -1)
                     (if (bobp) 0 (current-indentation)))
                   (progn
                     (goto-char end)
                     (forward-line 1)
                     (if (eobp) 0 (current-indentation)))))))
    ;; now expand the region
    (save-excursion
      (goto-char beg)
      (forward-line -1)
      (while (and (>= (current-indentation) n) (not (bobp)))
        (forward-line -1))
      (forward-line 1)
      (setq beg (point-at-bol))
      (goto-char end)
      (forward-line 1)
      (while (and (>= (current-indentation) n) (not (eobp)))
        (forward-line 1))
      (forward-line -1)
      (setq end (point-at-eol)))
    (goto-char beg)
    (set-mark beg)
    (goto-char end)))
#+END_SRC

* My env
#+BEGIN_SRC emacs-lisp
(defun my-set-major-mode ()
  "For temporary buffers, set the mode based on the name.
Defaults to text mode. Yasnippets won't be turned on for
Fundamental mode."
  (and (null (buffer-file-name))
       (eq major-mode 'fundamental-mode)
       (let ((mode (assoc-default (buffer-name)
                                  auto-mode-alist 'string-match)))
         (if (and mode (not (consp mode)))
             (funcall mode)
           (text-mode))
         t)))

(setq-default major-mode 'my-set-major-mode)

(let ((registers '((?d . "~/Desktop")
                   (?e . "~/my/dotfiles/emacs/emacs.d")
                   (?~ . "~"))))
  (dolist (reg registers)
    (set-register (car reg) (cons 'file (cdr reg)))))

(defun my-show-trailing-whitespace ()
  (setq show-trailing-whitespace t))

(let ((trailing-whitespace-mode-hooks
       '(ruby-mode-hook python-mode-hook
                        c-mode-hook
                        c++-mode-hook
                        js-mode-hook
                        java-mode-hook
                        diff-mode-hook
                        emacs-lisp-mode-hook)))
  (dolist (hook trailing-whitespace-mode-hooks)
    (add-hook hook 'my-show-trailing-whitespace)))

(require 'uniquify)
(setq uniquify-buffer-name-style 'post-forward-angle-brackets)

(setq message-log 16384)
(visual-line-mode 1)
(setq save-interprogram-paste-before-kill t)
(setq highlight-nonselected-windows t)
(setq echo-keystrokes 0.1)
(setq vc-follow-symlinks t)
(setq mouse-drag-copy-region t)
(setq-default indent-tabs-mode nil)
(setq make-backup-files nil)
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
(setq inhibit-startup-echo-area-message "sri")
(setq initial-scratch-message nil)
(setq visible-bell nil)
(setq ring-bell-function (lambda ()))
(setq disabled-command-hook nil)
(setq kill-whole-line t)
(setq kill-read-only-ok t)
(setq mouse-yank-at-point t)
(setq sentence-end-double-space nil)
;; Help char is `?' so C-x ? will list all the
;; keys bound to C-x.
(setq help-char ??)
(setq scroll-error-top-bottom t)

(setq Man-width 80)

(add-hook 'before-save-hook 'delete-trailing-whitespace)

(setq eval-expression-print-length nil)
(setq eval-expression-print-level nil)
(setq enable-recursive-minibuffers t)

(put 'erase-buffer 'disabled nil)
(fset 'yes-or-no-p 'y-or-n-p)

(winner-mode 1)
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(line-number-mode t)
(column-number-mode t)
(blink-cursor-mode -1)
(auto-compression-mode t)
(transient-mark-mode 1)
(show-paren-mode t)
(server-start)

(global-linum-mode 1)
(setq linum-format
      (if window-system "%d" "%d "))

(setq diff-switches '("-u"))

(make-variable-buffer-local 'line-number-mode)
(make-variable-buffer-local 'column-number-mode)

(require 'hippie-exp)

(setq hippie-expand-try-functions-list
      '(
        yas-hippie-try-expand
        try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name
        try-complete-lisp-symbol))

(global-font-lock-mode t)

(add-hook 'focus-out-hook
          (lambda ()
            (when (and buffer-file-name
                       (buffer-modified-p))
              (save-buffer))))

;; Help mode:
(require 'help-mode)

(defun my-help-push-next-button ()
  (interactive)
  (forward-button 1 t)
  (push-button))

(define-key help-mode-map (kbd "b") 'help-go-back)
(define-key help-mode-map (kbd "f") 'help-go-forward)
(define-key help-mode-map (kbd "n") 'forward-button)
(define-key help-mode-map (kbd "p") 'backward-button)
(define-key help-mode-map (kbd "x") 'delete-window)
(define-key help-mode-map (kbd "g") 'my-help-push-next-button)

;; Occur:
(defun my-occur-mode-display-occurrence ()
  (interactive)
  (occur-mode-display-occurrence)
  (occur-next))

(define-key occur-mode-map (kbd "n")
  'my-occur-mode-display-occurrence)

;; Eval expr:
(require 'eval-expr)

(eval-expr-install)
(setq eval-expr-print-function 'pp
      eval-expr-print-level nil
      eval-expr-print-length nil)

;; Shell:
(setenv "PAGER" "cat")

(defun my-shell-forward-char-or-previous-history (&optional arg)
  (interactive "p")
  (if (eobp)
      (comint-previous-input arg)
    (forward-char arg)))

(defun my-shell-next-line-or-next-history (&optional arg)
  (interactive "p")
  (if (eobp)
      (comint-next-input arg)
    (next-line arg)))

(defun my-shell-erase-buffer ()
  (interactive)
  (erase-buffer)
  (comint-send-input))

(defvar my-shell-bash-esc-dot-counter 0)
(defvar my-shell-bash-esc-dot-last-insertion nil)

(defun my-shell-bash-esc-dot ()
  "Same as Esc-. in bash; insert previous command's last word."
  (interactive)
  (let* ((continue (eq last-command 'my-shell-bash-esc-dot))
         (count (if continue (1+ my-shell-bash-esc-dot-counter) 0))
         (cmd (comint-previous-input-string count))
         (last (if (string-match "\\([`'\"]\\)[^`'\"]+?\\1\\s-*$" cmd)
                   (match-string 0 cmd)
                 (car (last (split-string cmd " " t))))))
    (setq my-shell-bash-esc-dot-counter count)
    (when last
      (when continue
        (delete-region (point)
                       (save-excursion
                         (search-backward my-shell-bash-esc-dot-last-insertion
                                          (point-at-bol)))))
      (setq my-shell-bash-esc-dot-last-insertion last)
      (insert last))))

(defun my-shell-bash-clear-screen ()
  (interactive)
  (recenter-top-bottom 0))

(defun my-shell (&optional arg)
  "Create a new shell (with prefix arg) or switch to a shell buffer."
  (interactive "P")
  (if arg
      (shell (generate-new-buffer-name "*shell*"))
    (let (shells others)
      (dolist (buf (buffer-list))
        (when (eq (with-current-buffer buf major-mode) 'shell-mode)
          (if (string-match "^[*]shell[*]" (buffer-name buf))
              (push buf shells)
            (push buf others))))
      ;; Sort the shells named "*shell*", "*shell*<1>" by their names.
      (setq shells (sort shells (lambda (x y)
                                  (string-lessp (buffer-name x)
                                                (buffer-name y)))))
      ;; Sort the shells not named "*shell*" etc. by their
      ;; creation time.
      (setq others (sort others (lambda (x y)
                                  (< (with-current-buffer x
                                       my-shell-mode-created-at)
                                     (with-current-buffer y
                                       my-shell-mode-created-at)))))
      (cond ((and (null shells) (null others))
             (shell))
            ((eq major-mode 'shell-mode)
             (let ((cur (current-buffer)))
               (switch-to-buffer (if (string-match "^[*]shell[*]" (buffer-name))
                                     (or (cadr (memq cur shells))
                                         (car others)
                                         (car shells))
                                   (or (cadr (memq cur others))
                                       (car shells)
                                       (car others))))))
            (t (switch-to-buffer (or (car shells)
                                     (car others))))))))

(defvar my-shell-mode-created-at nil)
(make-variable-buffer-local 'my-shell-mode-created-at)

(add-hook 'shell-mode-hook
          (lambda ()
            (setq my-shell-mode-created-at (float-time))
            (linum-mode -1)
            (setq line-number-mode nil
                  column-number-mode nil)
            (setq comint-input-ignoredups t)
            (setq comint-scroll-to-bottom-on-input nil)
            (setq comint-scroll-show-maximum-output nil)
            (toggle-truncate-lines 1)
            (define-key shell-mode-map (kbd "C-<up>")
              'comint-previous-prompt)
            (define-key shell-mode-map (kbd "C-<down>")
              'comint-next-prompt)
            (define-key shell-mode-map (kbd "C-c e")
              'my-shell-erase-buffer)
            (define-key shell-mode-map (kbd "C-l")
              'my-shell-bash-clear-screen)
            (define-key shell-mode-map (kbd "<right>")
              'my-shell-forward-char-or-previous-history)
            (define-key shell-mode-map (kbd "<down>")
              'my-shell-next-line-or-next-history)
            (define-key shell-mode-map (kbd "M-.")
              'my-shell-bash-esc-dot)))

;; Dired:
(require 'dired-x)

(defun my-dired ()
  (interactive)
  (let ((file-name buffer-file-name))
    (dired default-directory)
    (when file-name
      (dired-goto-file file-name))))

(defun my-dired-find-file ()
  (interactive)
  (if (/= (line-beginning-position) 1)
      (dired-find-file)
    (let ((dir (expand-file-name default-directory)))
      (kill-new dir)
      (message "Copied: '%s'" dir))))

(defun my-dired-first-file ()
  (interactive)
  (goto-char (point-min))
  (dired-next-line 1))

(defun my-dired-last-file ()
  (interactive)
  (goto-char (point-max))
  (dired-previous-line 1))

(defun my-dired-right-arrow-key ()
  (interactive)
  (if (or (let ((use-empty-active-region t))
            (use-region-p))
          (= (line-beginning-position) 1))
      (forward-char 1)
    (dired-find-file)))

(when (eq system-type 'darwin)
  (setq dired-guess-shell-alist-user
        '(("\\.pdf\\'" "open -a Preview")
          ("\\.html?\\'" "open -a 'Google Chrome'"))))

(add-hook 'dired-mode-hook
          (lambda ()
            (linum-mode -1)
            (dired-omit-mode 1)
            (dired-hide-details-mode 1)
            (define-key dired-mode-map (kbd "D") 'dired-hide-details-mode)
            (setq dired-dwim-target t)
            (setq dired-omit-size-limit nil)
            (define-key dired-mode-map (kbd ",") 'dired-prev-dirline)
            (define-key dired-mode-map (kbd ".") 'dired-next-dirline)
            (define-key dired-mode-map [mouse-2] 'dired-find-file)
            (define-key dired-mode-map "a" 'my-dired-first-file)
            (define-key dired-mode-map "z" 'my-dired-last-file)
            (define-key dired-mode-map "f" 'my-isearch-forward)
            (define-key dired-mode-map "r" 'wdired-change-to-wdired-mode)
            (define-key dired-mode-map (kbd "C-m") 'my-dired-find-file)
            (define-key dired-mode-map (kbd "SPC") 'scroll-up)
            (define-key dired-mode-map (kbd "S-SPC") 'scroll-down)
            (define-key dired-mode-map [left] 'dired-up-directory)
            (define-key dired-mode-map [right] 'my-dired-right-arrow-key)))

;; View:
(require 'view)

(defun my-view-scroll-down-one-line ()
  (interactive)
  (scroll-down 1))

(defun my-view-scroll-up-one-line ()
  (interactive)
  (scroll-up 1))

(defun my-view-top-of-window ()
  (interactive)
  (recenter 0))

(defun my-view-center-in-window ()
  (interactive)
  (recenter))

(defun my-view-botton-of-window ()
  (interactive)
  (recenter -1))

(define-key view-mode-map (kbd "SPC") 'View-scroll-page-forward)
(define-key view-mode-map (kbd "j") 'View-scroll-page-forward)
(define-key view-mode-map (kbd "S-SPC") 'View-scroll-page-backward)
(define-key view-mode-map (kbd "k") 'View-scroll-page-backward)
(define-key view-mode-map "q" 'View-exit-and-edit)
(define-key view-mode-map (kbd "a") 'beginning-of-buffer)
(define-key view-mode-map (kbd "z") 'end-of-buffer)
(define-key view-mode-map (kbd "f") 'my-isearch-forward)

(when window-system
  (global-hl-line-mode 1)

  (let ((shell-path (shell-command-to-string "$SHELL -c 'echo -n $PATH'")))
    (setenv "PATH" shell-path)
    (setq exec-path (split-string shell-path path-separator)))

  ;; Center Emacs's position on screen
  (let* ((height 40)
         (width 80)
         (screen-height (x-display-pixel-height))
         (screen-width (x-display-pixel-width))
         (top (/ (- screen-height (frame-pixel-height)) 2))
         (left (/ (- screen-width (frame-pixel-width)) 2)))
    (add-to-list 'default-frame-alist (cons 'height 40))
    (add-to-list 'default-frame-alist (cons 'width 80))
    (add-to-list 'default-frame-alist (cons 'top top))
    (add-to-list 'default-frame-alist (cons 'left left)))

  (set-frame-parameter nil 'alpha '(100 100))

  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (abbreviate-file-name (buffer-file-name))
                   "%b"))))

  ) ; window-system

#+END_SRC

* isearch improvements
#+BEGIN_SRC emacs-lisp
(defun my-isearch-search-for-selected ()
  (let ((isearch-word t)
        (isearch-forward t)
        (beg (min (mark) (point)))
        (string (buffer-substring-no-properties (mark) (point))))
    (unless (string-match "^\n*$" string)
      (deactivate-mark)
      (save-excursion
        (call-interactively 'isearch-forward)
        (goto-char beg)
        (isearch-yank-string string)
        (message "%d matches" (count-matches string
                                             (point-min)
                                             (point-max)))))))
(defun my-isearch-forward ()
  (interactive)
  (if (let (use-empty-active-region)
        (use-region-p))
      (my-isearch-search-for-selected)
    (call-interactively 'isearch-forward)))

(defun my-isearch-delete-region ()
  (interactive)
  (when isearch-other-end
    (delete-region (point) isearch-other-end)
    (isearch-done)))

;; TODO: handle wrap around
(defun my-isearch-goto-next-non-visible-match ()
  "Go to the next (or previous) match that isn't visible on screen."
  (interactive)
  (let ((next-non-visible-match
         (let ((search-spaces-regexp search-whitespace-regexp))
           (save-excursion
             (cond (isearch-forward
                    (goto-char (window-end))
                    (re-search-forward (regexp-quote isearch-string) nil t))
                   (t
                    (goto-char (window-start))
                    (re-search-backward (regexp-quote isearch-string) nil t)))))))
    (if (null next-non-visible-match)
        (message "No matches found beyond this window")
      (goto-char next-non-visible-match)
      (cond (isearch-forward
             (goto-char (point-at-bol))
             (recenter 4))
            (t
             (goto-char (point-at-eol))
             (recenter -4)))
      (isearch-search)
      (isearch-update))))

(defun my-isearch-yank-whole-word ()
  (interactive)
  (skip-chars-backward "a-zA-Z0-9_-")
  (isearch-yank-internal
   (lambda ()
     (skip-chars-forward "a-zA-Z0-9_-")
     (point))))

(setq isearch-allow-scroll t)
(setq isearch-lazy-highlight-initial-delay 0)

(define-key isearch-mode-map "\r" 'isearch-repeat-forward)
(define-key isearch-mode-map (kbd "<return>") 'isearch-repeat-forward)
(define-key isearch-mode-map (kbd "<S-return>") 'isearch-repeat-backward)
;(define-key isearch-mode-map (kbd "<backspace>") 'my-isearch-delete-region)
(define-key isearch-mode-map (kbd "C-K") 'isearch-query-replace-regexp)
(define-key isearch-mode-map (kbd "C-d") 'my-isearch-yank-whole-word)
(define-key isearch-mode-map (kbd "C-k") 'isearch-query-replace)
(define-key isearch-mode-map (kbd "C-o") 'isearch-occur)
(define-key isearch-mode-map (kbd "C-v") 'my-isearch-goto-next-non-visible-match)

#+END_SRC

* Key bindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-tab>") 'my-switch-to-buffer)
(global-set-key (kbd "C-\\") 'other-frame)
(global-set-key (kbd "C-a") 'my-beginning-of-line)
(global-set-key (kbd "C-b") 'backward-kill-word)
(global-set-key (kbd "C-d") 'kill-word)
(global-set-key (kbd "C-f") 'my-isearch-forward)
(global-set-key (kbd "C-i") 'my-hippie-tab)
(global-set-key (kbd "C-j") 'other-window)
(global-set-key (kbd "C-k") 'my-kill-line-or-region)
(global-set-key (kbd "C-m") 'newline-and-indent)
(global-set-key (kbd "C-n") 'execute-extended-command)
(global-set-key (kbd "C-o") 'my-ffap-or-find-file)
(global-set-key (kbd "C-p") 'my-shell)
(global-set-key (kbd "C-r") 'vr/query-replace)
(global-set-key (kbd "C-s") 'save-buffer)
(global-set-key (kbd "C-v") 'ivy-switch-buffer)
(global-set-key (kbd "C-w") 'my-kill-current-buffer)
(global-set-key (kbd "C-y") 'my-yank)
(global-set-key (kbd "C-z") 'undo)

(global-set-key (kbd "C-c C") 'org-capture)
(global-set-key (kbd "C-c TAB") 'yas/expand)
(global-set-key (kbd "C-c \\") 'align-regexp)
(global-set-key (kbd "C-c a") 'org-agenda)
(global-set-key (kbd "C-c c") 'calendar)
(global-set-key (kbd "C-c g") 'my-git-grep)
(global-set-key (kbd "C-c i") 'my-change-inside-pair)
(global-set-key (kbd "C-c l") 'toggle-truncate-lines)
(global-set-key (kbd "C-c o") 'occur)
(global-set-key (kbd "C-c s") 'sort-lines)

(global-set-key (kbd "<M-SPC>") 'my-just-one-space)
(global-set-key (kbd "<M-down>") 'scroll-up)
(global-set-key (kbd "<M-return>") 'my-dired)
(global-set-key (kbd "<M-up>") 'scroll-down)
(global-set-key (kbd "M-'") 'my-emacs-lisp-eval)
(global-set-key (kbd "M-,") 'beginning-of-buffer)
(global-set-key (kbd "M-.") 'end-of-buffer)
(global-set-key (kbd "M-0") 'delete-window)
(global-set-key (kbd "M-1") 'delete-other-windows)
(global-set-key (kbd "M-2") 'split-window-vertically)
(global-set-key (kbd "M-3") 'split-window-horizontally)
(global-set-key (kbd "M-;") 'my-comment-line-or-region)
(global-set-key (kbd "M-<down>") 'scroll-up)
(global-set-key (kbd "M-<up>") 'scroll-down)
(global-set-key (kbd "M-D") 'my-duplicate-line-or-region)
(global-set-key (kbd "M-E") 'mc/edit-lines)
(global-set-key (kbd "M-N") 'bm-previous)
(global-set-key (kbd "M-\\") 'my-delete-horizontal-space)
(global-set-key (kbd "M-b") 'bm-toggle)
(global-set-key (kbd "M-d") 'my-dired)
(global-set-key (kbd "M-g") 'goto-line)
(global-set-key (kbd "M-k") 'my-kill-whole-line)
(global-set-key (kbd "M-m") 'magit-status)
(global-set-key (kbd "M-n") 'bm-next)
(global-set-key (kbd "M-o") 'projectile-find-file)

(global-set-key (kbd "<home>") 'beginning-of-buffer)
(global-set-key (kbd "<end>") 'end-of-buffer)

(defvar ctl-c-r-map)
(define-prefix-command 'ctl-c-r-map)
(define-key global-map (kbd "C-c r") ctl-c-r-map)
(global-set-key (kbd "C-c r n") 'my-remove-non-ascii-chars)

(global-set-key (kbd "C-x l") 'my-count-lines-buffer)
(global-set-key (kbd "C-x r K") 'my-copy-from-starting-col-till-eol)
(global-set-key (kbd "C-x s") 'my-start-line-or-region-swap)
(global-set-key (kbd "C-x v -") 'my-unsaved-changes)

;; Unbind
(cl-flet ((unset-key-in-mode (mode &rest keys)
            (lexical-let ((keys keys)
                          (hook (intern (format "%s-hook" mode))))
              (add-hook hook
                        (lambda ()
                          (dolist (key keys)
                            (local-unset-key (kbd key))))))))

  (unset-key-in-mode 'lisp-interaction-mode "C-j")
  (unset-key-in-mode 'magit-status-mode "M-1" "M-2" "M-3")

  (let ((magit-modes '(magit-log-mode
                       magit-branch-manager-mode
                       magit-status-mode
                       magit-wazzup-mode
                       magit-log-edit-mode
                       magit-stash-mode
                       magit-reflog-mode
                       magit-diff-mode)))
    (dolist (mode magit-modes)
      (unset-key-in-mode mode "C-w")))

  (unset-key-in-mode 'shell-mode "C-d")

  (unset-key-in-mode 'org-mode "C-j" "C-," "<S-return>")

  )
#+END_SRC

* Some Miscellaneous functions
#+BEGIN_SRC emacs-lisp
(defvar my-change-inside-pair-overlay nil)
(make-variable-buffer-local 'my-change-inside-pair-overlay)

(defun my-change-inside-pair-unhighlight ()
  (delete-overlay my-change-inside-pair-overlay))

;; This shows a way to briefly highlight a region.
;; This done using the run-at-time function.
;; But that function can't delay execution depending
;; on what emacs is doing. See Emacs's compile.el
;; and search for pre-command-hook. It adds a pre-command-hook
;; that cancels the stored timer if execution of run-at-time
;; takes too long. And function remove itself from the pre-command-hook
;; after that.
(defun my-change-inside-pair (arg)
  (interactive "P")
  (let* ((start-string (format "%c" (read-event)))
         (end-string (or (cdr (assoc start-string '(("(" . ")")
                                                    ("{" . "}")
                                                    ("[" . "]")
                                                    ("<" . ">"))))
                         start-string))
         (start nil)
         (end nil))
    (save-excursion
      (when (search-forward start-string nil t)
        (setq start (point))
        (when (search-forward end-string nil t)
          (setq end (1- (point))))))
    (cond ((null start) (message "Couldn't find starting `%s'" start-string))
          ((null end) (message "Couldn't find ending `%s'" end-string))
          (arg (kill-ring-save start end)
               ;; Briefly highlight the copied region if its visible
               ;; to the user.
               (when (and (pos-visible-in-window-p start (selected-window))
                          (pos-visible-in-window-p end (selected-window)))
                 (when (null my-change-inside-pair-overlay)
                   (setq my-change-inside-pair-overlay (make-overlay 0 0))
                   (overlay-put my-change-inside-pair-overlay
                                'face 'isearch))
                 (move-overlay my-change-inside-pair-overlay
                               start
                               end
                               (current-buffer))
                 (run-at-time 0.3 nil 'my-change-inside-pair-unhighlight))
               (message "Copied `%s'"
                        (buffer-substring-no-properties start end)))
          (t
           (goto-char end)
           (delete-region start end)))))

(defun my-kill-line-or-region (&optional arg)
  (interactive "P")
  (if (use-region-p)
      (kill-region (point) (mark))
    (kill-line arg)))

(defun my-hippie-tab (arg)
  (interactive "*P")
  (cond ((and transient-mark-mode (use-region-p))
         (indent-region (region-beginning) (region-end) nil))
        ((and (eq (char-syntax (preceding-char)) ?w)
              (not (zerop (current-column))))
         (hippie-expand arg))
        (t
         (indent-for-tab-command))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun my-find-tag-next ()
  (interactive)
  (find-tag nil t nil))

(defun my-kill-current-buffer ()
  "Kill the current buffer without prompting."
  (interactive)
  (kill-buffer (current-buffer)))

(defun my-transpose-buffers (&optional arg)
  (interactive "p")
  (let* ((windows (window-list nil 'never-minibuffer))
         (selected (pop windows))
         (selected-buffer (window-buffer selected)))
    (when (< arg 0)
      (setq windows (reverse windows)))
    (dotimes (i (length windows))
      (switch-to-buffer (window-buffer (pop windows)))
      (other-window arg))
    (switch-to-buffer selected-buffer)
    (other-window arg)))

(defun my-switch-to-buffer ()
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(defvar my-yank-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "y") 'yank-pop)
    map))

(defun my-yank (arg)
  (interactive "*P")
  (yank arg)
  (unless (window-minibuffer-p)
    (message "Press `y' to yank-pop"))
  (set-temporary-overlay-map my-yank-keymap
                             (lambda ()
                               (memq this-command
                                     '(yank-pop cua-paste-pop)))))

(defun my-quick-hotkey ()
  "Temporarily bind a key to a hotkey.
Key can be any key that invokes a command.  Hotkey is a single
key. Any other key other than the hotkey exits this mode."
  (interactive)
  (let* ((cmd-key (read-key-sequence "Command key: " nil t))
         (cmd (intern-soft (key-binding cmd-key))))
    (if (null cmd)
        (message "No command associated with key `%s'" cmd-key)
      (let* ((prompt (format "Hot key to run `%s': " cmd))
             (hotkey (read-key prompt))
             (hotkey-string (format (if (numberp hotkey) "%c" "<%s>") hotkey))
             (map (make-sparse-keymap)))
        (define-key map (kbd hotkey-string) cmd)
        (call-interactively cmd)
        (set-temporary-overlay-map map t)
        (unless (window-minibuffer-p)
          (with-temp-message (format "`%s' will run the command `%s'"
                                     hotkey-string cmd)
            (sit-for 1.0)))))))

(defun my-count-lines-buffer ()
  (interactive)
  (message "%d lines" (count-lines (point-min) (point-max))))

(defun my-just-one-space (&optional arg)
  "Like just-one-space, but moves across newlines."
  (interactive "*P")
  (just-one-space (if arg nil -1)))

(defun my-delete-horizontal-space (&optional arg)
  (interactive "*P")
  (if arg
      (delete-horizontal-space)
    (delete-region (progn (skip-chars-backward " \t\n\r")
                          (point))
                   (progn (skip-chars-forward " \t\n\r")
                          (point)))))

(defun my-kill-whole-line (&optional arg)
  "Like kill-whole-line but maintains column position."
  (interactive "p")
  (let ((col (current-column)))
    (kill-whole-line arg)
    (move-to-column col)))

(defun my-find-in-directory ()
  (interactive)
  (if (use-region-p)
      (let* ((string (buffer-substring-no-properties (point) (mark)))
             (dir (read-directory-name (format "Searching for %s under: " string))))
        (ag string dir))
    (call-interactively 'ag)))

(defun my-url-decode (&optional arg)
  "Decode the URL.
If a region is selected and the universal argument (C-u) is prefixed,
then the region is replaced with the decoded URL. Otherwise, show the
decoded URL in the minibuffer."
  (interactive "P")
  (let* ((region-active (use-region-p))
         (url (if region-active
                  (buffer-substring-no-properties (point) (mark))
                (read-string "Url: ")))
         (decoded (url-unhex-string url)))
    (cond ((and region-active arg)
           (delete-region (point) (mark))
           (insert decoded))
          (t (message "%s" decoded)))))

(defun my-join-line-down ()
  (interactive)
  (message "down")
  (join-line 1))

(defun my-join-line-up ()
  (interactive)
  (join-line))

(defvar my-join-line-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map [up] 'my-join-line-up)
    (define-key map [down] 'my-join-line-down)
    map))

(defun my-join-line (&optional arg)
  (interactive "*P")
  (join-line arg)
  (message "Hit [up] or [down] to join line up or from below")
  (set-temporary-overlay-map my-join-line-keymap t))

(defun my-emacs-lisp-eval ()
  (interactive)
  (let ((fn (cond ((= (preceding-char) ?\)) 'eval-last-sexp)
                  ((use-region-p) 'eval-region)
                  (t 'eval-defun))))
    (call-interactively fn)))

(defun my-beginning-of-line ()
  "Move to the beginning of line or beginning of non-whitespace chars."
  (interactive "^")
  (if (= (current-column) 0)
      (back-to-indentation)
    (let ((point (point))
          (indentation-start (save-excursion
                               (back-to-indentation)
                               (point))))
      (goto-char (if (<= point indentation-start)
                     (point-at-bol)
                   indentation-start)))))

(require 'ffap)

(defun my-ffap-or-find-file (arg)
  (interactive "P")
  (if arg
      (call-interactively 'find-file)
    (let ((file-at-point (ffap-file-at-point)))
      (if file-at-point
          (let ((linenum
                 (save-excursion
                   (goto-char (point-at-bol))
                   (when (and (search-forward file-at-point (point-at-eol) t 1)
                              (looking-at ":\\([0-9]+\\)"))
                     (string-to-int (buffer-substring-no-properties
                                     (match-beginning 1)
                                     (match-end 1)))))))
            (find-file file-at-point)
            (when linenum
              (goto-line linenum)
              (linum-mode 1)))
        (call-interactively 'find-file)))))

(defun my-remove-non-ascii-chars ()
  (interactive)
  (query-replace-regexp "[^[:ascii:]]" ""))

(defun my-find-file-literally ()
  (interactive)
  (let ((path (buffer-file-name)))
    (kill-buffer (current-buffer))
    (find-file-literally path)))

(defvar my-selective-display-level 0)
(make-variable-buffer-local 'my-selective-display-level)

(defun my-selective-display-next (&optional arg)
  (interactive "P")
  (setq my-selective-display-level (or arg
                                       (if (> my-selective-display-level 8)
                                           0
                                         (+ my-selective-display-level 2))))
  (message "Selective display level: %s" my-selective-display-level)
  (set-selective-display my-selective-display-level))

(defun my-open-latest-downloaded-file ()
  (interactive)
  (let (downloads)
    (dolist (f (directory-files "~/Downloads" 'full nil 'nosort))
      (unless (member (file-name-nondirectory f) '("." ".."))
        (push (cons f (nth 5 (file-attributes f))) downloads)))
    (setq downloads
          (sort downloads (lambda (x y) (time-less-p (cdr y) (cdr x)))))
    (when downloads
      (find-file (caar downloads)))))

(require 'rect) ; for killed-rectangle
(defun my-copy-from-starting-col-till-eol (start end &optional evenly-sized-strings)
  "Copy from starting column till end of line for all lines in region.
With a prefix argument, makes all the copied lines the same
length -- spaces are appended to lines that aren't long enough.
Sets the result to `killed-rectangle', so that a `yank-rectangle'
will bring it back."
  (interactive "r\nP")
  (when (use-region-p)
    (let ((lines '())
          (line nil)
          (max 0)
          (start-column nil))
      (save-excursion
        (goto-char start)
        (setq start-column (current-column))
        ;; Don't include the last line unless the
        ;; cursor is at the end of the line.
        (while (<= (point-at-eol) end)
          (if (< (current-column) start-column)
              (push "" lines)
            (setq line (buffer-substring (point) (point-at-eol)))
            (setq max (max (length line) max))
            (push line lines))
          (forward-line 1)
          (move-to-column start-column))
        (setq lines (nreverse lines))
        (setq killed-rectangle
              (if evenly-sized-strings
                  (mapcar (lambda (s)
                            (concat s (make-string (- max (length s)) ? )))
                          lines)
                lines))
        (setq deactivate-mark t)
        (message "Invoke `yank-rectangle' (%s) to get this rectangle"
                 (mapconcat 'key-description
                            (where-is-internal 'yank-rectangle) ", "))))))

(defun my-unsaved-changes ()
  (interactive)
  (diff-buffer-with-file (current-buffer)))

;; Increase/decrease font size for all buffers.
;;
(defvar my-original-font-size nil)
(defun my-increase-font-size (&optional decrease)
  (interactive)
  (let* ((old (face-attribute 'default :height))
         ;; Increment has to be a multiple of 10.
         (new (+ old (if decrease (- 10) 10)))
         (inc))
    (when (null my-original-font-size)
      (setq my-original-font-size old))
    (setq inc (/ (- new my-original-font-size) 10))
    (message "%s%s: new font size: %s"
             (if (>= inc 0) "+" "-")
             inc
             new)
    (set-face-attribute 'default nil :height new)))
(defun my-decrease-font-size ()
  (interactive)
  (my-increase-font-size 'decrease))

(defun my-toggle-fullscreen ()
  (interactive)
  (cond ((eq window-system 'x)
         (let ((fullp (frame-parameter nil 'fullscreen)))
           (set-frame-parameter nil 'fullscreen
                                (if fullp nil 'fullscreen))))))

(defun my-frame-transparency (arg)
  (interactive "p")
  (set-frame-parameter nil 'alpha (list arg arg)))

#+END_SRC

* Load any private (work specific or home specific) files at the end

#+BEGIN_SRC emacs-lisp
  (let ((private (expand-file-name "~/.emacs.private.el")))
    (when (file-exists-p private)
      (load private)))
#+END_SRC
